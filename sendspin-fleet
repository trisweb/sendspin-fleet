#!/usr/bin/env bash

#==============================================================================
# sendspin-fleet - Fleet management tool for sendspin installations
#==============================================================================
# A simple fleet management script to check status and update sendspin-cli
# across multiple Linux hosts via SSH.
#==============================================================================

set -o nounset   # Exit on undefined variable
set -o pipefail  # Exit on pipe failure

#==============================================================================
# Configuration
#==============================================================================

# Default service user name (can be overridden via environment variable)
SENDSPIN_USER="${SENDSPIN_USER:-sendspin}"

# Default hosts configuration file
HOSTS_FILE="${HOSTS_FILE:-hosts.conf}"

#==============================================================================
# Output Helper Functions
#==============================================================================

# Color codes for terminal output
readonly COLOR_RESET="\033[0m"
readonly COLOR_HEADER="\033[1;96m"
readonly COLOR_SUBHEADER="\033[1;93m"
readonly COLOR_SUCCESS="\033[92m"
readonly COLOR_ERROR="\033[91m"
readonly COLOR_INFO="\033[36m"
readonly COLOR_WARNING="\033[33m"

# Print a header message
print_header() {
    echo -e "${COLOR_HEADER}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}" >&2
    echo -e "${COLOR_HEADER}  $1${COLOR_RESET}" >&2
    echo -e "${COLOR_HEADER}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}" >&2
}

# Print a subheader message
print_subheader() {
    echo -e "${COLOR_SUBHEADER}▶ $1${COLOR_RESET}" >&2
}

# Print a success message
print_success() {
    echo -e "${COLOR_SUCCESS}✔ $1${COLOR_RESET}" >&2
}

# Print an error message
print_error() {
    echo -e "${COLOR_ERROR}✘ $1${COLOR_RESET}" >&2
}

# Print an info message
print_info() {
    echo -e "${COLOR_INFO}ℹ $1${COLOR_RESET}" >&2
}

# Print a warning message
print_warning() {
    echo -e "${COLOR_WARNING}⚠ $1${COLOR_RESET}" >&2
}

# Print with hostname prefix
print_with_prefix() {
    local hostname="$1"
    local color="$2"
    local message="$3"
    echo -e "${color}[${hostname}]${COLOR_RESET} ${message}"
}

# Display usage information
show_usage() {
    print_header "sendspin-fleet - Fleet Management Tool"
    echo
    echo "Usage: $(basename "$0") <command>"
    echo
    print_subheader "Commands:"
    echo "  status          Check status, version, and name of all hosts (parallel)"
    echo "  update-system   Update system packages (apt update && upgrade) (parallel)"
    echo "  update-sendspin Update sendspin-cli package via uv (parallel)"
    echo "  update-all      Update both system packages and sendspin-cli (parallel)"
    echo "  help            Show this help message"
    echo
    print_subheader "Configuration:"
    echo "  Hosts file:     ${HOSTS_FILE}"
    echo "  Service user:   ${SENDSPIN_USER}"
    echo
    print_subheader "Environment Variables:"
    echo "  HOSTS_FILE      Path to hosts configuration file (default: hosts.conf)"
    echo "  SENDSPIN_USER   Service user name (default: sendspin)"
    echo
    print_subheader "Performance:"
    echo "  All operations run in parallel across hosts for maximum speed!"
    echo
}

# Read and parse the hosts configuration file
# Returns hosts as array of "hostname:user" pairs
read_hosts() {
    local hosts_file="$1"
    local -a hosts=()
    
    if [[ ! -f "${hosts_file}" ]]; then
        print_error "Hosts file not found: ${hosts_file}"
        print_info "Create ${hosts_file} with format: hostname:ssh_user (one per line)"
        exit 1
    fi
    
    while IFS= read -r line; do
        # Skip empty lines and comments
        [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue
        
        # Trim whitespace and add to array
        line=$(echo "${line}" | xargs)
        hosts+=("${line}")
    done < "${hosts_file}"
    
    if [[ ${#hosts[@]} -eq 0 ]]; then
        print_error "No hosts defined in ${hosts_file}"
        exit 1
    fi
    
    printf '%s\n' "${hosts[@]}"
}

# Parse a host entry into hostname and user
parse_host() {
    local host_entry="$1"
    local hostname="${host_entry%%:*}"
    local ssh_user="${host_entry##*:}"
    
    # If no colon, default to root
    if [[ "${hostname}" == "${ssh_user}" ]]; then
        ssh_user="root"
    fi
    
    echo "${hostname} ${ssh_user}"
}

# Execute SSH command on a remote host
ssh_exec() {
    local hostname="$1"
    local ssh_user="$2"
    local command="$3"
    
    ssh -o ConnectTimeout=10 \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${ssh_user}@${hostname}" \
        "${command}" 2>&1
}

#==============================================================================
# Parallel Execution Framework
#==============================================================================

# Execute a function for a single host (meant to be run in background)
execute_for_host() {
    local host_entry="$1"
    local operation="$2"
    
    read -r hostname ssh_user <<< "$(parse_host "${host_entry}")"
    
    # Call the specific operation function
    case "${operation}" in
        status)
            check_status_single "${hostname}" "${ssh_user}"
            ;;
        update-system)
            update_system_single "${hostname}" "${ssh_user}"
            ;;
        update-sendspin)
            update_sendspin_single "${hostname}" "${ssh_user}"
            ;;
    esac
}

# Run operation in parallel across all hosts
run_parallel() {
    local operation="$1"
    local -a hosts
    local -a pids=()
    
    mapfile -t hosts < <(read_hosts "${HOSTS_FILE}")
    
    print_info "Running on ${#hosts[@]} host(s) in parallel..."
    echo
    
    # Start all operations in parallel
    for host_entry in "${hosts[@]}"; do
        execute_for_host "${host_entry}" "${operation}" &
        pids+=($!)
    done
    
    # Wait for all background jobs to complete
    local failed=0
    for pid in "${pids[@]}"; do
        if ! wait "${pid}"; then
            ((failed++)) || true
        fi
    done
    
    echo
    if [[ ${failed} -eq 0 ]]; then
        print_success "All operations completed successfully"
    else
        print_warning "${failed} operation(s) had issues"
    fi
}

#==============================================================================
# Single Host Operation Functions (for parallel execution)
#==============================================================================

# Check status of a single host
check_status_single() {
    local hostname="$1"
    local ssh_user="$2"
    
    # Check SSH connectivity
    if ! ssh_exec "${hostname}" "${ssh_user}" "echo connected" &>/dev/null; then
        print_with_prefix "${hostname}" "${COLOR_ERROR}" "✘ Unable to connect via SSH"
        return 1
    fi
    
    print_with_prefix "${hostname}" "${COLOR_SUCCESS}" "✔ SSH connected"
    
    # Get service status
    local service_status
    service_status=$(ssh_exec "${hostname}" "${ssh_user}" \
        "systemctl is-active sendspin 2>/dev/null || echo 'not-found'")
    
    local status_msg
    case "${service_status}" in
        active)
            status_msg="${COLOR_SUCCESS}✔ Service: Running${COLOR_RESET}"
            ;;
        inactive|failed)
            status_msg="${COLOR_ERROR}✘ Service: Failed/Stopped${COLOR_RESET}"
            ;;
        *)
            status_msg="${COLOR_WARNING}⚠ Service: Unknown/Not Found${COLOR_RESET}"
            ;;
    esac
    print_with_prefix "${hostname}" "${COLOR_INFO}" "${status_msg}"
    
    # Get sendspin version
    local version
    version=$(ssh_exec "${hostname}" "${ssh_user}" \
        "sudo -u ${SENDSPIN_USER} /home/${SENDSPIN_USER}/.local/bin/sendspin --version 2>/dev/null || echo 'N/A'")
    print_with_prefix "${hostname}" "${COLOR_INFO}" "Version: ${version}"
    
    # Get configured name from settings
    local config_name
    config_name=$(ssh_exec "${hostname}" "${ssh_user}" \
        "sudo -u ${SENDSPIN_USER} cat /home/${SENDSPIN_USER}/.config/sendspin/settings-daemon.json 2>/dev/null | grep -oP '\"name\"\\s*:\\s*\"\\K[^\"]+' || echo 'N/A'")
    print_with_prefix "${hostname}" "${COLOR_INFO}" "Name: ${config_name}"
    
    return 0
}

# Update system packages on a single host
update_system_single() {
    local hostname="$1"
    local ssh_user="$2"
    
    # Check SSH connectivity
    if ! ssh_exec "${hostname}" "${ssh_user}" "echo connected" &>/dev/null; then
        print_with_prefix "${hostname}" "${COLOR_ERROR}" "✘ Unable to connect via SSH"
        return 1
    fi
    
    print_with_prefix "${hostname}" "${COLOR_INFO}" "Starting apt update && upgrade..."
    
    local update_output
    if update_output=$(ssh_exec "${hostname}" "${ssh_user}" \
        "sudo DEBIAN_FRONTEND=noninteractive apt update -qq && sudo DEBIAN_FRONTEND=noninteractive apt upgrade -y -qq" 2>&1); then
        print_with_prefix "${hostname}" "${COLOR_SUCCESS}" "✔ System packages updated"
        return 0
    else
        print_with_prefix "${hostname}" "${COLOR_ERROR}" "✘ System update failed"
        # Show error output with prefix
        echo "${update_output}" | while IFS= read -r line; do
            print_with_prefix "${hostname}" "${COLOR_ERROR}" "  ${line}"
        done
        return 1
    fi
}

# Update sendspin package on a single host
update_sendspin_single() {
    local hostname="$1"
    local ssh_user="$2"
    
    # Check SSH connectivity
    if ! ssh_exec "${hostname}" "${ssh_user}" "echo connected" &>/dev/null; then
        print_with_prefix "${hostname}" "${COLOR_ERROR}" "✘ Unable to connect via SSH"
        return 1
    fi
    
    print_with_prefix "${hostname}" "${COLOR_INFO}" "Upgrading sendspin via uv..."
    
    local update_output
    if update_output=$(ssh_exec "${hostname}" "${ssh_user}" \
        "sudo -u ${SENDSPIN_USER} /home/${SENDSPIN_USER}/.local/bin/uv tool upgrade sendspin" 2>&1); then
        print_with_prefix "${hostname}" "${COLOR_SUCCESS}" "✔ Sendspin package upgraded"
        
        # Show upgrade output with prefix
        echo "${update_output}" | while IFS= read -r line; do
            [[ -n "${line}" ]] && print_with_prefix "${hostname}" "${COLOR_INFO}" "  ${line}"
        done
    else
        print_with_prefix "${hostname}" "${COLOR_ERROR}" "✘ Sendspin upgrade failed"
        echo "${update_output}" | while IFS= read -r line; do
            print_with_prefix "${hostname}" "${COLOR_ERROR}" "  ${line}"
        done
        return 1
    fi
    
    # Restart service
    print_with_prefix "${hostname}" "${COLOR_INFO}" "Restarting sendspin service..."
    if ssh_exec "${hostname}" "${ssh_user}" "sudo systemctl restart sendspin" &>/dev/null; then
        print_with_prefix "${hostname}" "${COLOR_SUCCESS}" "✔ Service restarted"
        return 0
    else
        print_with_prefix "${hostname}" "${COLOR_WARNING}" "⚠ Service restart may have failed"
        return 1
    fi
}

#==============================================================================
# Command Implementations
#==============================================================================

# Get status of all hosts (parallel)
cmd_status() {
    print_header "Fleet Status Report"
    echo
    run_parallel "status"
}

# Update system packages on all hosts (parallel)
cmd_update_system() {
    print_header "Update System Packages"
    echo
    run_parallel "update-system"
}

# Update sendspin package on all hosts (parallel)
cmd_update_sendspin() {
    print_header "Update Sendspin Package"
    echo
    run_parallel "update-sendspin"
}

# Update both system packages and sendspin (parallel, but sequential operations)
cmd_update_all() {
    print_header "Update System and Sendspin"
    echo
    
    print_info "Updating system packages on all hosts in parallel..."
    echo
    run_parallel "update-system"
    
    echo
    print_info "Updating sendspin on all hosts in parallel..."
    echo
    run_parallel "update-sendspin"
}

#==============================================================================
# Main Script
#==============================================================================

main() {
    # Check if a command was provided
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
    fi
    
    local command="$1"
    
    # Execute the requested command
    case "${command}" in
        status)
            cmd_status
            ;;
        update-system)
            cmd_update_system
            ;;
        update-sendspin)
            cmd_update_sendspin
            ;;
        update-all)
            cmd_update_all
            ;;
        help|--help|-h)
            show_usage
            ;;
        *)
            print_error "Unknown command: ${command}"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
