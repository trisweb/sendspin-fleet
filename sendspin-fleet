#!/usr/bin/env bash

#==============================================================================
# sendspin-fleet - Fleet management tool for sendspin installations
#==============================================================================
# A simple fleet management script to check status and update sendspin-cli
# across multiple Linux hosts via SSH.
#==============================================================================

set -o nounset   # Exit on undefined variable
set -o pipefail  # Exit on pipe failure

#==============================================================================
# Configuration
#==============================================================================

# Default service user name (can be overridden via environment variable)
SENDSPIN_USER="${SENDSPIN_USER:-sendspin}"

# Default hosts configuration file
HOSTS_FILE="${HOSTS_FILE:-hosts.conf}"

#==============================================================================
# Output Helper Functions
#==============================================================================

# Color codes for terminal output
readonly COLOR_RESET="\033[0m"
readonly COLOR_HEADER="\033[1;96m"
readonly COLOR_SUBHEADER="\033[1;93m"
readonly COLOR_SUCCESS="\033[92m"
readonly COLOR_ERROR="\033[91m"
readonly COLOR_INFO="\033[36m"
readonly COLOR_WARNING="\033[33m"
readonly COLOR_DIM="\033[2m"

# ANSI cursor control
readonly CURSOR_HIDE="\033[?25l"
readonly CURSOR_SHOW="\033[?25h"
readonly CURSOR_SAVE="\033[s"
readonly CURSOR_RESTORE="\033[u"

# Spinner frames
readonly SPINNER_FRAMES=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')

# Print a header message
print_header() {
    echo -e "${COLOR_HEADER}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}" >&2
    echo -e "${COLOR_HEADER}  $1${COLOR_RESET}" >&2
    echo -e "${COLOR_HEADER}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}" >&2
}

# Print a subheader message
print_subheader() {
    echo -e "${COLOR_SUBHEADER}▶ $1${COLOR_RESET}" >&2
}

# Print a success message
print_success() {
    echo -e "${COLOR_SUCCESS}✔ $1${COLOR_RESET}" >&2
}

# Print an error message
print_error() {
    echo -e "${COLOR_ERROR}✘ $1${COLOR_RESET}" >&2
}

# Print an info message
print_info() {
    echo -e "${COLOR_INFO}ℹ $1${COLOR_RESET}" >&2
}

# Print a warning message
print_warning() {
    echo -e "${COLOR_WARNING}⚠ $1${COLOR_RESET}" >&2
}

# Cleanup function for TUI
cleanup_tui() {
    echo -e "${CURSOR_SHOW}" >&2
    [[ -n "${STATUS_DIR:-}" ]] && rm -rf "${STATUS_DIR}"
}

# Trap to ensure cursor is restored on exit
trap cleanup_tui EXIT INT TERM

# Display usage information
show_usage() {
    print_header "sendspin-fleet - Fleet Management Tool"
    echo
    echo "Usage: $(basename "$0") <command>"
    echo
    print_subheader "Commands:"
    echo "  status          Check status, version, and name of all hosts (parallel)"
    echo "  update-system   Update system packages (apt update && upgrade) (parallel)"
    echo "  update-sendspin Update sendspin-cli package via uv (parallel)"
    echo "  update-all      Update both system packages and sendspin-cli (parallel)"
    echo "  help            Show this help message"
    echo
    print_subheader "Configuration:"
    echo "  Hosts file:     ${HOSTS_FILE}"
    echo "  Service user:   ${SENDSPIN_USER}"
    echo
    print_subheader "Environment Variables:"
    echo "  HOSTS_FILE      Path to hosts configuration file (default: hosts.conf)"
    echo "  SENDSPIN_USER   Service user name (default: sendspin)"
    echo
    print_subheader "Performance:"
    echo "  All operations run in parallel across hosts for maximum speed!"
    echo
}

# Read and parse the hosts configuration file
# Returns hosts as array of "hostname:user" pairs
read_hosts() {
    local hosts_file="$1"
    local -a hosts=()
    
    if [[ ! -f "${hosts_file}" ]]; then
        print_error "Hosts file not found: ${hosts_file}"
        print_info "Create ${hosts_file} with format: hostname:ssh_user (one per line)"
        exit 1
    fi
    
    while IFS= read -r line; do
        # Skip empty lines and comments
        [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue
        
        # Trim whitespace and add to array
        line=$(echo "${line}" | xargs)
        hosts+=("${line}")
    done < "${hosts_file}"
    
    if [[ ${#hosts[@]} -eq 0 ]]; then
        print_error "No hosts defined in ${hosts_file}"
        exit 1
    fi
    
    printf '%s\n' "${hosts[@]}"
}

# Parse a host entry into hostname and user
parse_host() {
    local host_entry="$1"
    local hostname="${host_entry%%:*}"
    local ssh_user="${host_entry##*:}"
    
    # If no colon, default to root
    if [[ "${hostname}" == "${ssh_user}" ]]; then
        ssh_user="root"
    fi
    
    echo "${hostname} ${ssh_user}"
}

# Execute SSH command on a remote host
ssh_exec() {
    local hostname="$1"
    local ssh_user="$2"
    local command="$3"
    
    ssh -o ConnectTimeout=10 \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${ssh_user}@${hostname}" \
        "${command}" 2>&1
}

#==============================================================================
# TUI Display Functions
#==============================================================================

# Update status for a single host (writes to status file)
update_host_status() {
    local hostname="$1"
    local status="$2"
    local message="$3"
    
    local status_file="${STATUS_DIR}/${hostname}.status"
    echo "${status}|${message}" > "${status_file}"
}

# Draw the TUI display with proper in-place updates
draw_tui() {
    local -a hosts=("$@")
    local num_hosts=${#hosts[@]}
    
    # Hide cursor using tput if available, fallback to ANSI
    if command -v tput &>/dev/null; then
        tput civis 2>/dev/null || printf '%b' "${CURSOR_HIDE}" >&2
    else
        printf '%b' "${CURSOR_HIDE}" >&2
    fi
    
    # Print initial placeholder lines to reserve space
    local i
    for ((i=0; i<num_hosts; i++)); do
        local host_entry="${hosts[$i]}"
        read -r hostname ssh_user <<< "$(parse_host "${host_entry}")"
        printf '  %s: Waiting...\n' "${hostname}" >&2
    done
    
    # Monitor and update display
    local spinner_idx=0
    local all_done=false
    
    while [[ "${all_done}" == false ]]; do
        all_done=true
        
        # Move cursor up to start of our display area
        if command -v tput &>/dev/null; then
            tput cuu "${num_hosts}" 2>/dev/null || printf '\033[%dA' "${num_hosts}" >&2
        else
            printf '\033[%dA' "${num_hosts}" >&2
        fi
        
        for host_entry in "${hosts[@]}"; do
            read -r hostname ssh_user <<< "$(parse_host "${host_entry}")"
            local status_file="${STATUS_DIR}/${hostname}.status"
            
            # Read current status
            local status="running"
            local message="Connecting..."
            if [[ -f "${status_file}" ]]; then
                IFS='|' read -r status message < "${status_file}"
            fi
            
            # Clear line and move to beginning
            if command -v tput &>/dev/null; then
                tput el 2>/dev/null || printf '\033[2K' >&2
            else
                printf '\033[2K' >&2
            fi
            printf '\r' >&2
            
            # Build and print the line content
            case "${status}" in
                running)
                    all_done=false
                    local spinner="${SPINNER_FRAMES[$spinner_idx]}"
                    printf '%b%s%b %s: %s\n' "${COLOR_INFO}" "${spinner}" "${COLOR_RESET}" "${hostname}" "${message}" >&2
                    ;;
                success)
                    printf '%b✔%b %s: %s\n' "${COLOR_SUCCESS}" "${COLOR_RESET}" "${hostname}" "${message}" >&2
                    ;;
                error)
                    printf '%b✘%b %s: %s\n' "${COLOR_ERROR}" "${COLOR_RESET}" "${hostname}" "${message}" >&2
                    ;;
                warning)
                    printf '%b⚠%b %s: %s\n' "${COLOR_WARNING}" "${COLOR_RESET}" "${hostname}" "${message}" >&2
                    ;;
            esac
        done
        
        # Update spinner
        spinner_idx=$(( (spinner_idx + 1) % ${#SPINNER_FRAMES[@]} ))
        
        # Small delay to avoid CPU spinning
        sleep 0.1
    done
    
    # Show cursor again
    if command -v tput &>/dev/null; then
        tput cnorm 2>/dev/null || printf '%b' "${CURSOR_SHOW}" >&2
    else
        printf '%b' "${CURSOR_SHOW}" >&2
    fi
}

#==============================================================================
# Parallel Execution Framework
#==============================================================================

# Execute a function for a single host (meant to be run in background)
execute_for_host() {
    local host_entry="$1"
    local operation="$2"
    
    read -r hostname ssh_user <<< "$(parse_host "${host_entry}")"
    
    # Call the specific operation function
    case "${operation}" in
        status)
            check_status_single "${hostname}" "${ssh_user}"
            ;;
        update-system)
            update_system_single "${hostname}" "${ssh_user}"
            ;;
        update-sendspin)
            update_sendspin_single "${hostname}" "${ssh_user}"
            ;;
    esac
}

# Run operation in parallel across all hosts with TUI
run_parallel() {
    local operation="$1"
    local -a hosts
    local -a pids=()
    
    mapfile -t hosts < <(read_hosts "${HOSTS_FILE}")
    
    # Create temporary directory for status tracking
    STATUS_DIR=$(mktemp -d)
    export STATUS_DIR
    
    print_info "Running on ${#hosts[@]} host(s) in parallel..."
    echo >&2
    
    # Start all operations in parallel
    for host_entry in "${hosts[@]}"; do
        execute_for_host "${host_entry}" "${operation}" &
        pids+=($!)
    done
    
    # Draw TUI and monitor progress
    draw_tui "${hosts[@]}"
    
    # Wait for all background jobs to complete
    local failed=0
    for pid in "${pids[@]}"; do
        if ! wait "${pid}"; then
            ((failed++)) || true
        fi
    done
    
    # Cleanup
    rm -rf "${STATUS_DIR}"
    unset STATUS_DIR
    
    echo >&2
    if [[ ${failed} -eq 0 ]]; then
        print_success "All operations completed successfully"
    else
        print_warning "${failed} operation(s) had issues"
    fi
}

#==============================================================================
# Single Host Operation Functions (for parallel execution)
#==============================================================================

# Check status of a single host
check_status_single() {
    local hostname="$1"
    local ssh_user="$2"
    
    update_host_status "${hostname}" "running" "Connecting via SSH..."
    
    # Check SSH connectivity
    if ! ssh_exec "${hostname}" "${ssh_user}" "echo connected" &>/dev/null; then
        update_host_status "${hostname}" "error" "Unable to connect via SSH"
        return 1
    fi
    
    update_host_status "${hostname}" "running" "Checking service status..."
    
    # Get service status
    local service_status
    service_status=$(ssh_exec "${hostname}" "${ssh_user}" \
        "systemctl is-active sendspin 2>/dev/null || echo 'not-found'")
    
    update_host_status "${hostname}" "running" "Retrieving version info..."
    
    # Get sendspin version
    local version
    version=$(ssh_exec "${hostname}" "${ssh_user}" \
        "sudo -u ${SENDSPIN_USER} /home/${SENDSPIN_USER}/.local/bin/sendspin --version 2>/dev/null || echo 'N/A'")
    
    # Get configured name from settings
    local config_name
    config_name=$(ssh_exec "${hostname}" "${ssh_user}" \
        "sudo -u ${SENDSPIN_USER} cat /home/${SENDSPIN_USER}/.config/sendspin/settings-daemon.json 2>/dev/null | grep -oP '\"name\"\\s*:\\s*\"\\K[^\"]+' || echo 'N/A'")
    
    # Build final status message
    local service_icon="⚠"
    local final_status="success"
    case "${service_status}" in
        active)
            service_icon="✔"
            ;;
        inactive|failed)
            service_icon="✘"
            final_status="warning"
            ;;
    esac
    
    update_host_status "${hostname}" "${final_status}" "${service_icon} ${config_name} | ${version} | ${service_status}"
    return 0
}

# Update system packages on a single host with progress tracking
update_system_single() {
    local hostname="$1"
    local ssh_user="$2"
    
    update_host_status "${hostname}" "running" "Connecting via SSH..."
    
    # Check SSH connectivity
    if ! ssh_exec "${hostname}" "${ssh_user}" "echo connected" &>/dev/null; then
        update_host_status "${hostname}" "error" "Unable to connect via SSH"
        return 1
    fi
    
    update_host_status "${hostname}" "running" "Running apt update..."
    
    if ! ssh_exec "${hostname}" "${ssh_user}" "sudo DEBIAN_FRONTEND=noninteractive apt update -qq" &>/dev/null; then
        update_host_status "${hostname}" "error" "apt update failed"
        return 1
    fi
    
    # Count upgradable packages
    update_host_status "${hostname}" "running" "Checking upgradable packages..."
    local upgradable_count
    upgradable_count=$(ssh_exec "${hostname}" "${ssh_user}" \
        "apt list --upgradable 2>/dev/null | grep -c upgradable || echo 0")
    upgradable_count=${upgradable_count//[^0-9]/}  # Strip non-digits
    
    if [[ "${upgradable_count}" -eq 0 ]]; then
        update_host_status "${hostname}" "success" "System is up to date (0 packages)"
        return 0
    fi
    
    update_host_status "${hostname}" "running" "Upgrading ${upgradable_count} packages..."
    
    # Run upgrade and track progress by counting installed packages
    # Use a remote script that outputs progress
    local upgrade_script='
        count=0
        total='"${upgradable_count}"'
        sudo DEBIAN_FRONTEND=noninteractive apt upgrade -y 2>&1 | while read -r line; do
            if [[ "$line" =~ ^(Setting up|Unpacking) ]]; then
                ((count++))
                echo "PROGRESS:$count/$total"
            fi
        done
        echo "DONE"
    '
    
    local current_pkg=0
    local last_update=0
    
    # Stream the output and update progress
    ssh -o ConnectTimeout=10 \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "${ssh_user}@${hostname}" \
        "bash -c '${upgrade_script}'" 2>&1 | while IFS= read -r line; do
        if [[ "${line}" =~ ^PROGRESS:([0-9]+)/([0-9]+) ]]; then
            current_pkg="${BASH_REMATCH[1]}"
            total_pkg="${BASH_REMATCH[2]}"
            # Only update every few packages or at end to reduce file writes
            if [[ $((current_pkg - last_update)) -ge 1 ]] || [[ "${current_pkg}" == "${total_pkg}" ]]; then
                update_host_status "${hostname}" "running" "Upgrading packages: ${current_pkg}/${total_pkg}"
                last_update="${current_pkg}"
            fi
        elif [[ "${line}" == "DONE" ]]; then
            break
        fi
    done
    
    # Verify upgrade completed
    local remaining
    remaining=$(ssh_exec "${hostname}" "${ssh_user}" \
        "apt list --upgradable 2>/dev/null | grep -c upgradable || echo 0")
    remaining=${remaining//[^0-9]/}
    
    if [[ "${remaining}" -eq 0 ]]; then
        update_host_status "${hostname}" "success" "Upgraded ${upgradable_count} packages"
        return 0
    else
        update_host_status "${hostname}" "warning" "Upgraded, but ${remaining} packages still pending"
        return 0
    fi
}

# Update sendspin package on a single host
update_sendspin_single() {
    local hostname="$1"
    local ssh_user="$2"
    
    update_host_status "${hostname}" "running" "Connecting via SSH..."
    
    # Check SSH connectivity
    if ! ssh_exec "${hostname}" "${ssh_user}" "echo connected" &>/dev/null; then
        update_host_status "${hostname}" "error" "Unable to connect via SSH"
        return 1
    fi
    
    update_host_status "${hostname}" "running" "Upgrading sendspin via uv..."
    
    local update_output
    if update_output=$(ssh_exec "${hostname}" "${ssh_user}" \
        "sudo -u ${SENDSPIN_USER} /home/${SENDSPIN_USER}/.local/bin/uv tool upgrade sendspin" 2>&1); then
        
        # Extract version if possible
        local new_version=$(echo "${update_output}" | grep -oP 'sendspin.*\K\d+\.\d+\.\d+' | head -1)
        if [[ -n "${new_version}" ]]; then
            update_host_status "${hostname}" "running" "Upgraded to v${new_version}, restarting service..."
        else
            update_host_status "${hostname}" "running" "Package upgraded, restarting service..."
        fi
    else
        update_host_status "${hostname}" "error" "Sendspin upgrade failed"
        return 1
    fi
    
    # Restart service
    if ssh_exec "${hostname}" "${ssh_user}" "sudo systemctl restart sendspin" &>/dev/null; then
        update_host_status "${hostname}" "success" "Upgraded and service restarted"
        return 0
    else
        update_host_status "${hostname}" "warning" "Upgraded but service restart may have failed"
        return 1
    fi
}

#==============================================================================
# Command Implementations
#==============================================================================

# Get status of all hosts (parallel)
cmd_status() {
    print_header "Fleet Status Report"
    echo
    run_parallel "status"
}

# Update system packages on all hosts (parallel)
cmd_update_system() {
    print_header "Update System Packages"
    echo
    run_parallel "update-system"
}

# Update sendspin package on all hosts (parallel)
cmd_update_sendspin() {
    print_header "Update Sendspin Package"
    echo
    run_parallel "update-sendspin"
}

# Update both system packages and sendspin (parallel, but sequential operations)
cmd_update_all() {
    print_header "Update System and Sendspin"
    echo
    
    print_info "Updating system packages on all hosts in parallel..."
    echo
    run_parallel "update-system"
    
    echo
    print_info "Updating sendspin on all hosts in parallel..."
    echo
    run_parallel "update-sendspin"
}

#==============================================================================
# Main Script
#==============================================================================

main() {
    # Check if a command was provided
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
    fi
    
    local command="$1"
    
    # Execute the requested command
    case "${command}" in
        status)
            cmd_status
            ;;
        update-system)
            cmd_update_system
            ;;
        update-sendspin)
            cmd_update_sendspin
            ;;
        update-all)
            cmd_update_all
            ;;
        help|--help|-h)
            show_usage
            ;;
        *)
            print_error "Unknown command: ${command}"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
